\chapter{Estat de l'art}
\label{cap:estat-de-l-art}

Aquest capítol té per objectiu resumir i ordenar de forma estructurada la
recerca inicial que s'ha fet per a aquest projecte. Només es posarà èmfasi en
les parts rellevants per al projecte, però sempre s'inclourà alguna referència
per complementar o ampliar algun concepte.

\section{Protocol USB}

Sent la connexió \acro{usb} un dels punts més cèntrics d'aquest treball de
fi de grau, s'ha iniciat la recerca per aquest cantó. No només s'ha escollit
usar aquest estàndard per la seva compatibilitat
i les facilitats que proporciona a l'usuari, sinó que també hi havia un interès
personal en entendre aquest protocol.

L'\acro{usb}, que significa \est{Universal Serial Bus} en anglès, és un
estàndard de comunicació que permet la connexió, intercanvi i transferència de
dades entre dispositius electrònics com ara ordinadors, telèfons mòbils, i
impressores. Aquesta tecnologia utilitza uns connectors estàndards que són
àmpliament reconeguts per la seva facilitat d'ús i versatilitat en una àmplia
gamma d'aplicacions. Els dispositius \acro{usb} poden transmetre dades a
diferents velocitats, des de velocitats molt baixes fins a velocitats molt
altes, i són compatibles amb una gran varietat de sistemes operatius i
maquinari \cite{Axelson2015USB}.

\subsection{Arquitectura}

L'arquitectura del \acro{usb} és de tipus mestre-esclau, en què el mestre sol ser
l'ordinador i l'esclau el dispositiu que es connecta. Com es veurà a l'Apartat
\ref{sec:usb_versions}, s'acabarà utilitzant la versió \acro{usb2}. Per
evitar fer molt extens aquest document, només es detallarà l'arquitectura
d'aquesta versió.

\subsubsection*{Aspectes físics}
\label{subsub:usb_physic}

El baix nivell no es detallarà en excés, ja que s'utilitzaran llibreries que
compleixen l'estàndard des d'un nivell més alt. Tanmateix, s'ha trobat
interessant fer una pinzellada de l'estàndard.

El connector \acro{usb2} està compost de quatre cables: \acro{5v}, \acro{gnd},
\acro{d+} i \acro{d-}. La funció del cable de \acro{5v} és alimentar el
dispositiu, amb una intensitat de fins a
\SI[round-mode=places,round-precision=0]{500}{\milli\ampere}. Aquestes
prestacions de corrent resulten ser suficients per a la major part dels
dispositius que compleixen l'estàndard. Sabent que \acro{gnd} és el cable
necessari per tancar els circuits, només queda \acro{d+} i \acro{d-} per
enviar dades.

Contràriament al que es podria pensar, el flux de dades (i electricitat) no
està predefinit: en un moment pot ser l'ordinador el que utilitzi els dos cables
per transmetre dades al dispositiu, i en un altre pot ser a l'inrevés. De fet,
els dos cables sempre envien el mateix, però de manera invertida; això es coneix
com a tensió en mode diferencial. D'aquesta manera, les interferències en mode
comú (respecte
\acro{gnd}) es poden eliminar (restant els dos senyals). La tensió en mode
diferencial funciona de forma òptima si els dos cables estan trenats (d'aquesta
forma reben gairebé la mateixa interferència, que s'anu\l.la quan es fa la
resta) \cite{DiffTension}.

És important tenir en compte que la tensió d'operació de l'estàndard \acro{usb2}
és de
\SI[round-mode=places,round-precision=1]{3.3}{\volt}, encara que la tensió que
proporciona el cable d'alimentació sigui de
\SI[round-mode=places,round-precision=0]{5}{\volt}.
Aquest detall serà molt important de cara
al disseny del dispositiu, ja que implicarà, molt probablement, l'ús de dos
díodes Zener a l'entrada de les línies de transmissió de dades.

A la figura \ref{fig:usb-wave} es pot veure un exemple de transacció \acro{usb}.
Hi ha un preàmbul per sincronitzar el rellotge dels dos dispositius i una
transmissió de dades fins que \acro{d+} i \acro{d-} deixen de tenir valors
invertits.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{images/usb_signal_example.png}
    \caption{Exemple de transmissió \acro{usb}. \cite{Contributors2024USB}}
    \label{fig:usb-wave}
\end{figure}

\subsubsection*{Transaccions}

Tal com s'ha comentat en l'apartat anterior, el canal de transmissió que
proporciona l'estàndard és unidireccional o \est{half-duplex}. En aquest
apartat es defineixen els tres tipus de transaccions.

Una transacció és un seguit d'intercanvi de dades entre l'ordinador i el
dispositiu. Totes s'inicien des de l'ordinador, encara que el paquet que es
vulgui enviar sigui en sentit invers. No s'entra en detall sobre el protocol de
connexió, ja que per aquest treball no té importància.

Existeixen tres tipus de transaccions:
\begin{itemize}
    \item Les transaccions \emph{out} serveixen per enviar paquets de
    l'ordinador al dispositiu.
    \item Les transaccions \emph{in} serveixen per enviar paquets del
    dispositiu a l'ordinador. A diferència del tipus anterior, aquesta
    transacció no la inicia qui vol enviar el paquet. Per poder
    superar aquest obstacle s'utilitza el següent tipus.
    \item Les transaccions de control serveixen per poder esbrinar quan el
    dispositiu necessita enviar dades, pactar velocitats de transmissió, entre
    d'altres. La transacció de control més important és la \emph{setup},
    que serveix per intercanviar informació inicial entre els dispositius. Més
    endavant es veuran els tipus de dades que s'intercanvien inicialment.
\end{itemize}

L'important d'aquest apartat és tenir present que les transaccions \emph{in} i
\emph{out} es van dissenyar per mantenir un intercanvi de dades constant,
mentre que les transaccions de control, fora de l'etapa de \emph{setup}, estan
més pensades per a petits intercanvis de dades, i més irregulars. Més endavant,
aquesta informació resultarà important per entendre la implementació del
dispositiu.

\subsubsection*{Modes de transmissió}

Un mode de transmissió és una descripció de quines transaccions i quan s'han
d'enviar per aconseguir un objectiu específic. Existeixen quatre modes
de transacció, descrits en la taula \ref{tab:transmision-modes}.

\input{misc/transmission_modes.tex}

Com es pot veure, amb aquests modes ja es cobreixen gairebé la totalitat dels
usos típics del protocol \acro{usb}: un micròfon o altaveu, un sensor, un
disc dur, entre d'altres. En el cas del dispositiu que es vol crear, el mode més
adequat és el d'interrupcions, ja que el sensor farà lectures a una freqüència
constant.

\subsubsection*{Metadades}
\label{subsubsec:metadades}

Durant els intercanvis inicials, durant l'etapa \emph{setup}, el dispositiu
comparteix certes metadades a l'ordinador, fet que li permet identificar-se
i descriure les especificacions necessàries. Un dels avantatges més visibles
d'aquest procés invisible és la funcionalitat \est{plug\&play}, que evita
insta\l.lar programari per a cada nou dispositiu que es connecta. El paquet
que s'intercanvia inicialment s'anomena \emph{Descriptor de dispositiu}.

Dos codis molt importants en aquest procés són el \acro{vid} i el \acro{pid},
acrònims de \est{Vendor ID} i \est{Product ID}. El \acro{vid} identifica
l'organisme que ha emès el dispositiu, i el \acro{pid} identifica el producte.
Cal tenir present que aquests dos codis són idèntics per a tots els dispositius
que es produeixin, per la qual cosa no té res a veure amb un número de sèrie. El motiu
pel qual es divideix el codi en dos nombres diferents recau en la forma en què
s'assignen als dispositius, tal com s'explicarà més endavant. Tanmateix,
a efectes tècnics es considera com un únic nombre.

Aquests codis tenen per objectiu que l'ordinador pugui identificar el tipus de
dispositiu que s'ha connectat. Un dels usos principals d'aquesta funcionalitat
és la creació de regles \acro{udev}, que en els sistemes de Linux assignen
\est{drivers} en funció dels codis anteriorment esmentats.

Una altra metadada que s'intercanvia a l'inici de la connexió és la classe
de dispositiu. Aquesta pot diferenciar entre dispositius multimedia, Hubs
\acro{usb}, teclats i ratolins, etcètera. Un dels grups més grans és el
\acro{hid}, o \est{Human Interface Devices}, una classe de dispositiu tan
versàtil que també s'utilitza en el protocol \est{Bluetooth}. S'explicarà amb
detall la classe \acro{hid} a l'apartat \ref{sec:hut}.

Finalment, hi ha altres metadades que poden ser interessants de conèixer, com
poden ser les freqüències en què el dispositiu envia dades o versions de
l'estàndard.

\subsubsection*{Interfícies i \est{Endpoints}}

Dintre de les metadades que s'envien en el descriptor de dispositiu hi ha els
descriptors de configuració. Aquests poden tenir una o diverses interfícies, que
al seu torn poden tenir un o més \est{endpoints}. Tot plegat queda amb una
jerarquia, tal com es pot veure a la figura \ref{fig:usb-endpoints}.

\input{misc/usb_endpoint_hyerarchy.tex}

Es començarà a explicar aquesta estructura des del nivell més baix. Un
\est{endpoint} és un canal de comunicació entre el dispositiu i l'ordinador.
Aquest es configura amb un dels modes mencionats anteriorment. Normalment, es
comença a contar a partir del número 1, donat que es reserva l'\est{endpoint}
0 per a trames de control de la interfície.

És molt comú que un \est{driver} necessiti més d'un \est{endpoint} per
comunicar-se amb el dispositiu. Per exemple, un teclat pot enviar dades de les
tecles premudes a través de l'\est{endpoint} 1 i rebre informació de l'ordinador
(com, per exemple, una ordre per encendre el llum del Bloq Mayus) a través de
l'\est{endpoint} 2. En aquest cas hi ha un \est{endpoint} en mode d'interrupció
i un altre en mode de control (només rebrà trames \est{out} de tant en tant).

Els \est{endpoints} s'agrupen en interfícies. L'ordinador pot tractar cada
interfície independentment i assignar diferents \est{drivers} per a cada una
d'elles. Així doncs, un teclat pot utilitzar el \est{driver} per defecte del
sistema operatiu i a la vegada tenir una interfície amb \est{drivers} específics
per a aquell model concret per tal de, per exemple, fer animacions amb la
retroi\l.luminació. És important utilitzar sempre que es pugui \est{drivers}
estàndards ja que, en el cas concret del teclat, permet que aquest segueixi
funcionant en un sistema operatiu que no disposi dels \est{drivers}
específics (com podria ser un entorn de \acro{bios}).

Finalment, les interfícies es poden agrupar en descriptors de configuració.
Aquests descriptors estan pensats per a dispositius que tenen dos modes
diferenciats, com per exemple un convertidor d'\acro{usb} a Jack d'àudio. Aquest
dispositiu pot funcionar tant d'entrada (connectant un micròfon) com de sortida
(connectant un altaveu), però no d'entrada i de sortida a la vegada. En aquest
cas hi haurà dos descriptors de configuració, i el dispositiu o el sistema
operatiu decidiran quin utilitzar en cada cas.

\subsection{\est{USB Implementers Forum}}
\label{subsec:usb-if}

El logo d'\acro{usb} i les imatges derivades estan sota drets d'autor. L'entitat
que gestiona qui pot utilitzar-los en el seu producte és l'\acro{usb-if},
provinent de l'anglès \est{\acro{Usb} Implementers Forum}. Aquesta entitat està
formada per moltes empreses tecnològiques multinacionals \cite{USBGetting}.
Per poder dir que un producte ofereix connectivitat \acro{usb}, l'empresa
fabricant necessita el permís d'\acro{usb-if}. No només això: per complir
l'estàndard, cal utilitzar un codi \acro{vid} i \acro{pid} únics per a cada
producte (no per a cada dispositiu). Aquests codis també els gestiona aquesta
entitat.

Per poder obtenir els drets d'ús de la imatge d'\acro{usb} i un codi
\acro{VID} (i, en conseqüència, \num[round-mode=places,round-precision=0]{65536}
codis \acro{pid}), s'ha de ser o bé
membre de l'\acro{usb-if} o bé pagar una llicència anual. El
primer dels casos val \SI[round-mode=places,round-precision=0]{5000}{\$}
anualment, mentre que el segon
val \SI[round-mode=places,round-precision=0]{6000}{\$}
%d'entrada i \SI{3500}{\$} cada dos anys
\cite{USBGetting}. Els membres d'\acro{usb-if} també poden participar en les
decisions dels nous estàndards d'\acro{usb}.

Com és d'imaginar, aquestes quotes no són assequibles per a petites empreses
o aficionats que volen treure un producte al mercat. Aquest co\l.lectiu,
generalment, només desitjaria tenir un identificador (\acro{vid} i \acro{pid})
únic per evitar algun possible solapament amb altres productes, però
no sol estar interessat en utilitzar la imatge d'\acro{usb} per promocionar
el seu producte.

Aquest projecte cau en aquest co\l.lectiu. Per decidir com prosseguir, s'ha
observat el que fa la comunitat d'aficionats quan es topa amb aquest problema.
Es recomana llegir la publicació de \cite{Johnson2023usb} si es desitja entendre
els motius d'\acro{usb-if} per posar aquests preus o no cedir \acro{vid}
a projectes de programari i/o maquinari lliure.

Resumidament, en aquests casos es disposa de dues alternatives:

\begin{enumerate}
    \item Inventar-se un \acro{vid} i \acro{pid}: Ja que en cap moment s'ha
    signat cap contracte amb l'\acro{usb-if}, i cap llei vigent ho impedeix, es
    podria escollir un \acro{vid} i \acro{pid} arbitraris i l'\acro{usb-if} no
    podria dir o fer res al respecte. Si s'escull amb cura, la
    probabilitat que els codis escollits co\l.lisionin amb el d'un altre
    producte és molt baixa. Tot i que aquesta metodologia és bona i ràpida per a
    prototips, no es recomana per a productes comercialitzables, en què el risc
    de co\l.lisió és més alt.
    \item Aconseguir un únic \acro{pid}: Les entitats que han comprat un codi
    \acro{vid} a l'\acro{usb-if} disposen de
    \num[round-mode=places,round-precision=0]{65536} codis \acro{pid}. La majoria
    d'entitats no necessiten més d'uns pocs codis \acro{pid}, i poden arribar
    a cedir la resta a projectes com \est{OpenMoko} \cite{OpenMokoUSB}. Aquests
    projectes s'encarreguen d'assignar codis \acro{pid} a altres d'arbitraris.
    Generalment, el seu únic requisit és que el projecte sigui de programari
    i maquinari lliures. Arran d'això, l'\acro{usb-if} va modificar el contracte
    de cessió de codis \acro{vid} l'any 2012, en el qual citava explícitament que no es
    podien cedir codis \acro{pid} a tercers \cite{Johnson2023usb}. Per aquest
    motiu, projectes com \est{OpenMoko} només poden utilitzar com a codis
    \acro{vid} base aquells que s'hagin adquirit abans d'aquest canvi
    de condicions.
\end{enumerate}

El producte d'aquest treball de fi de grau encaixa perfectament en els dos
grups, en funció del moment del projecte: mentre s'estigui desenvolupant, es
pot optar per utilitzar codis definits arbitràriament i, en el moment de
comercialitzar-lo, es pot so\l.licitar un codi \acro{pid} a \est{OpenMoko}.

\subsection{Versions}
\label{sec:usb_versions}

Durant els 30 anys d'\acro{usb-if} han sorgit diferents versions de
l'estàndard. Aquestes es poden dividir en grans grups:

\begin{itemize}
    \item \acro{Usb1}: Aquesta primera versió, projectada l'any 1996, oferia
    una velocitat màxima de transmissió de
    \SI[round-mode=places,round-precision=0]{12}{\mega\bit\per\second}.
    Aquesta versió es considera obsoleta i no s'hi haurien de crear nous dispositius
    amb aquesta.
    \item \acro{Usb2}: La segona versió utilitzava el mateix connector que el
    seu predecessor, però aprofitava els avenços de la tecnologia per
    augmentar la velocitat de transmissió a
    \SI[round-mode=places,round-precision=0]{480}{\mega\bit\per\second}.
    \item \acro{Usb3}: Aquesta versió utilitzava nous connectors, però tots
    eren compatibles amb les versions anteriors. La seva darrera revisió,
    \acro{usb3.2}, pot transmetre dades a
    \SI[round-mode=places,round-precision=0]{20}{\giga\bit\per\second}.
    \item \acro{Usb4}: Encara en fase de desenvolupament, aquesta nova versió
    utilitzaria només el connector \acro{usb-c}, que ja va aparèixer oferint
    compatibilitat fins a l'\acro{usb2}. Es calcula que podria quadruplicar
    la velocitat de transmissió amb relació a l'\acro{usb3.2}.
\end{itemize}

Les versions de l'estàndard estan dissenyades de forma que sempre tenen
compatibilitat envers les anteriors. Per tant, la recomanació general per als
desenvolupadors de dispositius és utilitzar la mínima versió possible, sense
perjudicar el rendiment del dispositiu  \cite{Axelson2015USB}. D'aquesta forma,
el dispositiu podrà funcionar en el nombre màxim d'ordinadors possible.

Sabent que la primera versió està obsoleta, s'ha escollit utilitzar la versió
\acro{usb2} per a aquest projecte, donat que no es necessita transmetre gran
volum de dades.

\subsection{Connectors i cables}

Entre totes les especificacions de l'estàndard \acro{usb} també s'hi troben les
dels cables. Tot i la ignorància general, els allargadors d'\acro{usb}, tinguin
el connector que tinguin, no estan suportats en l'estàndard, i pot ser que
hi hagi interferències \cite{Contributors2024USB}. En canvi, sí que
hi ha definits els \est{Hubs}, que permeten connectar més d'un dispositiu en un
connector, ja que l'electrònica que inclouen eviten pèrdues de dades.

L'estàndard \acro{usb} disposa de diferents connectors. Es poden distingir en
tres grans grups: A, B i C:

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.4\textwidth]{images/usb_connectors.png}
    \caption{Connectors \acro{usb} de tipus A i B. \cite{Contributors2024USB}}
    \label{fig:usb_connectors}
\end{figure}

\begin{itemize}
    \item Els connectors de tipus A són els que es connecten al dispositiu
    que actuarà com a mestre. Existeixen les variants \est{micro} i \est{mini},
    com es pot observar a la Figura \ref{fig:usb_connectors}, tot i que aquestes
    no són gaire populars. Amb l'aparició de l'estàndard \acro{usb3} es van
    dissenyar nous connectors que fossin compatibles amb els dels estàndards
    anteriors.
    \item Els connectors de tipus B són els que es connecten a l'esclau. Aquests
    també tenen les variants \est{micro} i \est{mini}, molt utilitzades
    en l'electrònica domèstica. També es van crear nous connectors de tipus B
    per poder acollir l'estàndard \acro{usb3}.
    \item Finalment, els connectors de tipus C no tenen una jerarquia definida:
    serveixen per a dispositius que poden ser mestres o esclaus en diferents
    moments donats. La decisió de qui actua de mestre es pacta just a l'inici
    de la connexió, mitjançant un protocol específic \cite{Axelson2015USB}.
    Aquest connector, a diferència de la resta, és reversible: es pot connectar
    en les dues orientacions possibles. Es pot veure l'aspecte del connector
    a la Figura \ref{fig:usb_connectors_c}.
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.2\textwidth]{images/usb_c.png}
    \caption{Connector \acro{usb} de tipus C. \cite{Contributors2024USB}}
    \label{fig:usb_connectors_c}
\end{figure}

Així doncs, gairebé la totalitat de cables \acro{usb} seran de tipus A a tipus
B, utilitzant qualsevol format de mida. El tipus C, com que és bidireccional, pot
substituir el tipus A o el tipus B en els cables mencionats anteriorment.
Quan un cable només té un connector de tipus C en un cantó, no s'ha de pactar
la jerarquia de mestre-esclau, ja que ve definida pel tipus de connector a
l'altra banda del cable. Evidentment, també hi pot haver cables de tipus C a
tipus C.

Tanmateix, l'any 2022 el Consell de la Unió Europea va aprovar una llei
que obliga un seguit de dispositius electrònics a utilitzar el connector
\acro{usb-c} en lloc d'altres estàndards \cite{Council2022Common}. Segons la
nota de premsa, el motiu d'aquesta llei és per evitar més deixalla electrònica
per culpa de tenir diferents dispositius amb diferents connectors, així com
facilitar l'ús de les tecnologies als consumidors. Aquesta llei
es començarà a aplicar a finals de l'any 2024, i afectarà dispositius mòbils, 
alguns portàtils, tauletes, teclats i ratolins sense fil, entre
d'altres.

Com que el dispositiu que es vol crear en aquest projecte és un perifèric de
l'ordinador, la llei citada no l'afectaria. Tanmateix, la mateixa nota de premsa
informa sobre la intenció d'estendre l'obligació a altres dispositius.
Tenint present que el dispositiu que es vol crear podria entrar fàcilment en
aquest grup de perifèrics d'ordinador, s'ha decidit utilitzar un connector de
tipus \acro{usb-c} per assegurar-nos la seva possible comercialització dintre
de la UE.

\section{Dispositius d'interfície humana}
\label{sec:hut}

Els dispositius d'interfície humana, o \acro{hid} (de l'anglès
\est{Human Interface Devices}) són una categoria de dispositius que o bé recullen
accions fetes per persones o bé els hi lliuren una sortida. Dintre d'aquesta
definició hi tenen cabuda teclats, ratolins, pantalles, sensors, entre d'altres.
Aquest terme s'utilitza per definir el concepte \acro{usb-hid}, una de les
classes \acro{usb} amb què un dispositiu pot identificar-se.

El protocol \acro{usb-hid} (d'ara endavant \acro{hid}) defineix una jerarquia
de subclasses per classificar els dispositius. En funció de la subclasse,
l'ordinador podrà decidir si utilitzar un \est{driver} o un altre. El protocol
també defineix la forma amb la qual s'envien les dades en funció del tipus de
dispositiu. Es pot veure el llistat de classes i subclasses \acro{hid} a la
documentació oficial d'\acro{usb-if} \cite{HidDefinition}.

El principal avantatge és que els dispositius
\acro{hid} utilitzen protocols ja establerts per poder ser utilitzats
sense haver d'insta\l.lar programari nou a l'ordinador (el que es coneix com
a \est{plug\&play}). Així doncs, quan es defineix un tipus \acro{hid} concret
s'ha de complir amb l'estàndard de comunicació associat.

Un dels altres avantatges d'utilitzar la classe \acro{hid} és que, com que és
una una capa per sobre del protocol \acro{usb}, n'és independent. En altres paraules,
altres protocols de comunicació també poden beneficiar-se de \acro{hid}, no
només \acro{usb}. Per aquest motiu, quan es va implementar \est{Bluetooth},
es va decidir utilitzar també \acro{hid} \cite{BluetoothHid}.

\subsection{\est{HID Report Descriptor}}

Un cop es presenta un dispositiu (o un \est{endpoint}) com a \acro{hid}
(mitjançant les metadades), s'ha d'enviar una nova capçalera de metadades a
l'ordinador que doni més informació sobre el dispositiu. Aquest paquet s'anomena
\est{\acro{Hid} Report Descriptor} i envia informacions molt detallades de
quin dispositiu és i com envia les dades.

Per exemple, un ratolí definirà que cada poc temps l'ordinador podrà fer-li
una petició de noves dades, i que aquestes tindran el format de tres valors
d'1 bit (pels tres botons), i dos valors de 8 bits (per saber la distància
desplaçada en cadascun dels eixos de coordenades). Aquesta capçalera també
especificarà que el dispositiu és un ratolí. Un cop enviat aquest paquet,
l'ordinador ja sabrà com comunicar-se amb el
dispositiu i com interpretar les dades que anirà enviant.

La documentació oficial d'\acro{usb} \cite{HidHut} especifica
detalladament tots els codis que es poden definir. El que interessarà per a
aquest treball és la categoria de \emph{Sensors}, i dintre d'aquesta hi ha
diversos tipus de dispositius. Veurem que el tipus \est{3D Accelerometer} serà
el més adequat per al projecte.

Aquesta documentació anterior es pot complementar amb una guia d'interpretació
de la documentació de Linux \cite{LinuxHid} en la qual es presenten diferents eines
per interpretar millor aquests paquets. Tot i que n'hi ha moltes que
funcionen des del terminal, la més visual i popular és \est{wireshark}.

Quan s'ha enviat el \est{\acro{Hid} Report Descriptor} es considera que
s'ha acabat la fase d'inicialització, i l'ordinador podrà demanar al
dispositiu els \est{Reports} que ha definit a la capçalera anterior.
Hi ha diferents tipus de \est{Reports}, que varien en funció del tipus de
dispositiu. Els més comuns són els tipus \est{feature}, \est{input} i \est{output},
que es definiran més endavant. Els reports es poden demanar també mitjançant
interrupcions de transmissió \est{in}.

A la figura \ref{fig:hid-packets} es pot veure un exemple simplificat d'un
intercanvi de paquets entre l'ordinador i el dispositiu. Es diu simplificat
perquè hi ha moltes més transmissions, i només s'ha decidit incloure les
rellevants per a aquest apartat. Per exemple, l'inicialització de la capa
\acro{usb} comporta molts més intercanvis que els que hi ha escrits, i la fase
de lectura de dades es pot fer en qualsevol ordre. En tot cas, és important
veure com totes les comunicacions són iniciades per l'ordinador.

\input{misc/hid_packets.tex}

\subsection{Cas concret: acceleròmetre tridimensional}

Tal com es veurà més endavant, s'acabarà utilitzant la categoria de
\est{3D Accelerometer} per designar el tipus de dispositiu. Aquesta
categoria (i la resta de dispositius dins del subgrup de sensors) necessita
reportar un seguit de dades, i no totes són òbvies.

A continuació es detallen les diferents dades que s'han d'enviar. Tal com s'ha
comentat anteriorment, en el \est{\acro{hid} report descriptor} es definirà
el tipus de dispositiu i el format i valors de les dades que s'enviarà, juntament
amb la freqüència amb què l'ordinador les pot so\l.licitar.

\begin{itemize}
    \item En primer lloc, s'ha de comunicar el tipus exacte de dispositiu. En
    aquest cas, la categoria de sensors i el tipus acceleròmetre tridimensional.
    \item S'ha de comunicar el tipus de connexió amb l'ordinador: integrat a
    la mateixa màquina, extern o adjunt. En el cas d'aquest projecte s'utilitzarà
    el tipus \emph{adjunt}, ja que es troba a molta proximitat de l'ordinador
    i en reportarà dades (el tipus extern seria per a sensors que
    mesuren variables d'altres aparells).
    \item També s'han de reportar els esdeveniments que pugui tenir el sensor.
    En aquest cas no se n'ha de reportar cap, així que en aquest paquet
    es definirà solament el tipus genèric \est{No Events}.
    \item L'estat d'alimentació del dispositiu també serà constant per a
    aquest dispositiu (no s'implementarà mode \est{sleep} o de baix consum, i
    la diferència de consum mentre que s'agafen mostres i mentre que
    s'espera una nova lectura de dades és poc significativa). Tanmateix, el
    protocol també ordena enviar-ho de la mateixa forma que la resta d'estats.
    \item El següent valor a enviar és l'estat del sensor. Aquest sí que serà
    diferent en funció de les dades que reporti el sensor. Per exemple, pot
    reportar que hi ha noves dades, que s'està inicialitzant, que hi ha un
    error en la lectura de dades, entre d'altres.
    \item També es reportarà l'interval que proposa el dispositiu entre
    diferents \est{reports}, és a dir, el temps que separarà cada trama de
    tipus \acro{in}.
    \item Finalment, hi ha les dades que es volen enviar. En la capçalera inicial
    s'especificaran moltes configuracions amb relació a les dades: valor màxim,
    mínim, factor d'escala, estat de les dades. Es recomana llegir la
    documentació proposada o veure exemples per entendre la immensitat
    d'aquesta informació.
\end{itemize}

Un cop enviada aquesta capçalera,
l'ordinador podrà demanar tantes vegades com vulgui els valors de les dades, és
a dir, els \est{Reports} definits anteriorment.
Concretament, en el cas d'aquest sensor, l'ordinador podrà demanar dos tipus
de \est{Reports}: \est{feature} i \est{input}.

\begin{itemize}
    \item El tipus \est{feature} enviarà l'estat del sensor: connexió, dades,
    interval entre comunicacions, sensitivitat i esdeveniments.
    \item El tipus \est{input} enviarà l'estat del sensor i, si s'escau, els
    valors llegits. Aquests valors s'hauran de dividir pel factor especificat
    a la capçalera per poder representar decimals. En el cas de l'acceleròmetre,
    la unitat a enviar és $g$, i gairebé mai aquest valor superarà
    les poques unitats; per tant, disposar de decimals és essencial.
\end{itemize}

La tasca que caldrà efectuar quan es dissenyi el programari serà convertir la
informació anterior en el format desitjat per al protocol \acro{hid}. Per sort,
existeixen programes i eines que ajuden a generar aquests codis, tal com
es veurà més endavant.

% Antic subapartat V-USB
\section{Implementacions del protocol USB en AVR}

Un cop es coneix el funcionament del protocol \acro{usb} i se sap quines trames
cal enviar, s'ha d'esbrinar com es pot comunicar un microcontrolador amb
una arquitectura \acro{avr8} amb l'ordinador. En aquest apartat es detallen
les diferents possibilitats que s'han descobert al llarg d'aquest projecte.

\subsection{Perifèrics incorporats}

El primer que s'ha cercat són els microcontroladors amb arquitectura \acro{avr8} que
tinguessin un perifèric \acro{usb} integrat. S'ha trobat la família
\acro{AtMegaXXuX} (en què les X poden ser diferents nombres) de l'empresa
\acro{atmel} \cite{AtMega32u4}. Aquests dispositius, que tenen una \emph{u} en
el seu nom (per remarcar que disposen del perifèric \acro{usb}), permetrien
una comunicació molt senzilla amb l'ordinador.

El dispositiu que més es comentarà durant aquest document és l'\acro{AtMega32u4},
que, en formar part de la placa Arduino Leonardo, és molt fàcil poder fer-hi
proves. També es veurà com s'acaba descartant l'ús de microcontroladors amb
perifèrics incorporats a causa de la diferència de preu en comparació amb les
alternatives següents.

\subsection{Llibreria LUFA}

La llibreria \acro{lufa} és una implementació del protocol \acro{usb} en
programari \cite{Lufa}. Disposa d'una llicència molt permissiva (\acro{mit}) i
funciona amb un gran nombre de dispositius \acro{avr}. De segur que és una
alternativa a tenir present quan s'ha de prendre una decisió com l'actual.

Tanmateix, aquesta llibreria necessita uns perifèrics i maquinari específics
(temporitzadors, freqüència de rellotge, \dots) per funcionar correctament.
Això limita considerablement el nombre de dispositius que es poden triar, ja que
no tots els microcontroladors \acro{avr8} compleixen els requisits que
demana \acro{lufa}. Aquest és el principal motiu pel qual s'acabarà escollint la
darrera opció per al projecte.

\subsection{Llibreria V-USB}

La llibreria \acro{v-usb}, implementada per \est{Objective Development} \cite{Vusb},
implementa la capa més baixa d'\acro{usb} a l'arquitectura
\acro{avr}, sense utilitzar perifèrics específics. Així doncs, gràcies a aquesta
llibreria no serà necessari utilitzar un microcontrolador \acro{avr} dotat amb
perifèrics \acro{usb}, com podria ser, per exemple, l'\acro{AtMega32u4}.

Aquesta llibreria 
es distribueix amb la llicència \acro{gpl-2+}, que obliga a
distribuir sota la mateixa llicència (o versions posteriors) tots els
projectes que facin servir la llibreria. L'empresa ofereix el concepte de
llicència dual: a part de \acro{gpl-2+}, se'n pot comprar una de comercial
per poder generar codi sota altres llicències \cite{VusbLicensing}.

Com que no s'utilitzen perifèrics específics, \acro{v-usb} no pot ca\l.librar amb
precisió el rellotge i els nivells de voltatge per complir el protocol \acro{usb}
amb perfecció. Així doncs, s'ha de tenir present que, per llicenciar un
dispositiu davant d'\acro{usb-if} potser hi haurà alguna complicació més que
habitualment.

A \cite{Vusb} hi ha el codi font de la llibreria, que s'ha d'incloure en el
projecte que s'estigui desenvolupant com a submòdul de \est{git}
\footnote{
    Els submòduls de \est{git}, o \est{Git Submodules}, serveixen per
    situar un repositori de \est{git} en un directori que forma part d'un altre
    repositori de \est{git}. Això permet mantenir els dos projectes separats
    mentre que eines com \est{gcc} poden disposar de l'estructura de
    fitxers necessària \cite{GitSubmodule}.
}, i també s'hi troben exemples de dispositius
senzills (ratolins i teclats) implementats amb aquesta llibreria. Tanmateix,
s'ha trobat el repositori de \cite{VusbProjects} més interessant, ja que conté
exemples de sensors \acro{hid}.

\section{\est{Drivers} a Linux}

Un altre dels aspectes importants del projecte és la creació d'un programari
que pugui fer d'intermediari entre el dispositiu i l'entorn gràfic. Tal com es
mostra en el títol de l'apartat, es comentarà només el cas específic dels sistemes
\acro{unix}, concretament amb Linux, ja que aquest sistema és l'objectiu
principal del projecte.

\subsection{Capes d'abstracció}

El \est{kernel} de Linux acostuma a dividir-ho tot en diferents capes, i no és una
excepció per al que té referència amb aquest projecte. Sempre és recomanable
treballar amb la capa més alta possible, ja que sovint això significa
estalviar-se feina. Tanmateix, és important comprendre d'on es ve per
poder entendre millor els errors i les dificultats que es trobaran en aquest treball.

A la figura \ref{fig:linux-stack} es pot veure una esquematització de la pila
de capes de \est{drivers} que el dispositiu haurà de travessar. Com es pot
veure, la capa més elevada engloba més tipus de dispositius, per la qual cosa aquesta
darrera abstracció aporta molts avantatges a l'hora de fer el programa més
versàtil. Evidentment, l'esquema és una simplificació, ja que darrere de cada
\est{driver} hi ha molta lògica que no hi hauria temps d'explicar en aquest
document.

\input{misc/linux_iio_stack.tex}

\subsubsection*{Capa 1: \est{libusb}}

\est{Libusb} és una llibreria multiplataforma i disponible per a diversos
llenguatges que permet realitzar una comunicació amb dispositius \acro{usb} en
la capa més baixa possible. En aquest nivell es poden enviar trames de control,
entrada o sortida a nivell de bits i bytes \cite{Libusb}.

Tot i que la llibreria es va pensar inicialment per a Linux, sota el nom de
\est{Linux-\acro{Usb}} \cite{LinuxUsb}, s'ha portat a Windows i MacOS,
convertint-la en la millor alternativa per generar programes multiplataforma
que necessitin controladors personalitzats.

Tanmateix, aquest projecte es beneficiarà de les capes de més alt nivell, per la qual cosa
serà més fàcil utilitzar les altres llibreries, tot i que això pugui suposar
efectuar petits canvis entre els diferents sistemes operatius.

A Linux, un dispositiu que es pot controlar per \est{libusb} sol aparèixer com
a fitxer sota el format \fitx{/dev/usbrawX}, en què X és el número de dispositiu.
No gens menys, si un controlador d'una capa superior està utilitzant
exclusivament el dispositiu, el \est{kernel} no crearà aquest fitxer, per
evitar confusió i solapaments.

\subsubsection*{Capa 2: \est{libhid} i \est{hidapi}}

La següent llibreria és la capa immediatament superior a la de l'apartat
anterior. \est{Libhid} permet gestionar dispositius \acro{hid}. D'aquesta
llibreria ha nascut \est{hidapi}, que l'engloba i la converteix en
una abstracció compatible amb altres sistemes operatius, com
FreeBSD, Windows i MacOS \cite{Libhid}. Tal com s'ha dit a 
l'apartat \ref{sec:hut}, també permetrà utilitzar dispositius Bluetooth.

Com que aquesta llibreria és una abstracció més elevada, existeixen més aplicacions
per provar-la i depurar-la. Sobretot es destaca \cite{LibhidUI}, que disposa
d'una interfície molt senzilla d'utilitzar i multiplataforma.

A Linux, un dispositiu que es pot controlar per \est{libhid} sol aparèixer com
a fitxer sota el format \fitx{/dev/hidrawX}, en què X és el número de dispositiu.
De la mateixa forma que amb l'apartat anterior, el dispositiu no apareixerà
sota aquest format si una capa més alta l'està utilitzant exclusivament.

\subsubsection*{Capa 3: \est{libiio}}

Finalment, la darrera capa d'abstracció de la pila d'aquest projecte és la
llibreria \acro{libiio}.
Aquesta llibreria permet interaccionar amb el sistema
\acro{iio} de Linux. També està disponible per a diversos llenguatges, però
a diferència de la resta d'abstraccions, no és multiplataforma.

El sistema \acro{iio}, o \est{Industrial Input/Output}, és la capa d'abstracció
dels sistemes basats en Linux per a qualsevol dispositiu que suposi una entrada
o sortida per al sistema i no tingui controladors dedicats. Per exemple, un
ratolí o un teclat no entraria dins d'aquest grup, ja que disposa de controladors
propis \cite{Iio}.

Hi ha moltes formes de veure quines categories de dispositius \acro{hid} es
converteixen en \acro{iio}, però la més senzilla és consultant el codi
font de Linux \cite{KernelIioAccel}. Pel que fa a aquest projecte, es pot veure
que existeix un \est{driver} per a \est{hid\_accelerometer\_3d} i, per tant, el
dispositiu d'aquest treball anirà en aquesta capa superior.

Mitjançant normes \acro{udev} es podria aconseguir que un dispositiu que per 
defecte s'assigna a \acro{iio} es quedi una capa més per sota, com seria
\acro{hid} o \acro{usb}. Tanmateix, \acro{iio} aporta molts beneficis.

\begin{itemize}
    \item No necessita permisos suplementaris per llegir les dades dels
    sensors. Per tant, no s'ha d'afegir l'usuari en un grup nou ni crear
    cap regla \acro{udev}.
    \item Més d'un usuari o procés pot estar llegint simultàniament el sensor.
    El dispositiu creat a \fitx{/dev/iio:deviceX} (en què X és el número de
    dispositiu) pot ser llegit simultàniament, de la mateixa forma que ho fan
    altres fitxers, per exemple \fitx{/dev/rand} o \fitx{/dev/zero}.
    \item En ser una capa superior, no s'ha de gestionar tot el referent al
    protocol \acro{hid}. Les lectures del sensor venen gairebé completament
    processades.
    \item Finalment, en ser una capa superior, també hi tenen cabuda altres
    sensors que podrien servir per al projecte, però que no són \acro{hid}.
\end{itemize}

Així doncs, es pagarà el preu de generar programari no compatible amb altres
dispositius a canvi de generar programari robust i a la capa més alta possible
per Linux. Pot semblar una mala decisió, però es veurà en el següent apartat
que tampoc seria possible generar un controlador 100 \% multiplataforma.

\subsection{Gestió i assignació de dispositius}

Un sistema operatiu amb tantes capes d'abstracció necessita forçosament una
aplicació que gestioni quina preval i quins usuaris hi poden accedir.
\acro{Udev} és el gestor de dispositius per a sistemes basats en Linux.
Té com a objectiu gestionar dinàmicament els dispositius de maquinari del
sistema, és a dir, és el responsable que si es connecta o desconnecta
un dispositiu mentre l'ordinador està encès, tot funcioni amb normalitat \cite{Udev}.

El funcionament d'\acro{udev} es basa en un conjunt de regles,
que es configuren per
determinar com han de gestionar-se els dispositius detectats.
Aquestes regles es poden configurar i modificar i, en el cas d'aquest projecte,
s'utilitzaran exclusivament per permetre a tots els usuaris utilitzar alguns
dispositius concrets, siguin quins siguin els permisos. Tanmateix, \acro{udev}
ofereix molta flexibilitat: es poden executar \est{scripts}, canviar el nom,
crear un volum, entre moltes altres possibilitats.

Com és d'esperar, només un usuari amb permisos d'administrador podrà configurar
les regles \acro{udev}, i hi ha molts paràmetres per configurar al màxim
aquestes regles. Tanmateix, com que aquestes normes només seran d'utilitat durant
el procés de desenvolupament del dispositiu, s'ha decidit no entrar gaire en
detalls de la implementació.

\subsubsection*{Exemples d'ús d'UDEV}

Un clàssic cas d'ús d'\acro{udev} és quan es vol que un dispositiu \acro{usb}
concret (identificat a través de la parella de codis \acro{vid}-\acro{pid})
sigui accessible per a un usuari concret. Això és necessari, per exemple, per
poder programar una placa Arduino o similar sense haver d'utilitzar permisos
d'administrador cada vegada.
Tot i que en aquest exemple la solució més encertada seria afegir l'usuari
corresponent al grup \fitx{dialout}, també es pot assolir l'objectiu proposat
afegint una regla \acro{udev}.

El següent fitxer, anomenat \fitx{49-micronucleus.rules}, permet programar una
placa \est{Digispark} mitjançant l'ordre \ord|micronucleus|. El nom del fitxer
comença amb un nombre per un motiu concret: el \est{kernel} carregarà totes les
regles que hi hagi a \fitx{/etc/udev/rules.d/} en ordre alfabètic dels fitxers.
A partir d'aquest requisit s'ha creat una convenció per utilitzar dos nombres
per ordenar aquests fitxers \cite{Udev}.

A continuació es mostra el contingut del fitxer
\footnote{
    Les regles \acro{udev} no poden tenir salts de línia. Per facilitar la
    lectura s'ha utilitzat la contrabarra per representar les regles en
    diferents línies, però copiades literalment donarien en un error.
}:

\begin{verbatim}
SUBSYSTEMS=="usb", ATTRS{idVendor}=="16d0", ATTRS{idProduct}=="0753", \
                   MODE:="0666"
KERNEL=="ttyACM*", ATTRS{idVendor}=="16d0", ATTRS{idProduct}=="0753", \
                   MODE:="0666", ENV{ID_MM_DEVICE_IGNORE}="1"
\end{verbatim}

Com es pot veure, hi ha dues regles:
\begin{itemize}
    \item La primera donarà accés a tots els usuaris (posant el mode
    \texttt{0666}) a tots els dispositius que utilitzin el \est{driver}
    \texttt{usb} i que tinguin el \acro{vid} i \acro{pid} assenyalats.
    \item La segona realitza el mateix, però amb aquells que utilitzin el
    \est{driver} \texttt{ttyACM} (dispositius de comunicació). També evita que
    el \est{driver} del mòdem (\est{ModemManager}) prengui control del
    dispositiu fent que l'ignori.
\end{itemize}

\subsubsection*{Assignar \est{drivers} específics}

Com s'ha vist a l'exemple anterior, és possible crear regles \acro{udev} per
canviar el \est{driver} o controlador d'un dispositiu. També es poden desvincular
controladors mitjançant l'ordre \ord|udevadm|, que, com que no modifica cap fitxer
a \fitx{/etc}, no és persistent.

Així doncs, gràcies a aquesta ordre o a la configuració de regles \acro{udev},
es pot evitar que un dispositiu utilitzi un \est{driver} d'una capa superior.
És possible, doncs, mostrar un fitxer \fitx{/dev/usbrawX} d'un dispositiu
\acro{hid} \cite{unbindingHid}, tot i que per defecte aquests utilitzin
\fitx{libhid} i no \fitx{libusb}.

\section{Execució en segon pla a Linux}
\label{subsec:systemd}

El programari que es pretén realitzar per a aquest projecte involucra la
presència d'un procés que, en tot moment, comprovi les lectures del sensor i
actualitzi l'orientació de la pantalla. L'usuari és responsable d'insta\l.lar i
configurar el programa, però un cop configurat, aquest hauria de funcionar
sempre correctament, fins i tot després de reiniciar l'ordinador.

En els sistemes basats en Linux, els programes que estan en execució tota
l'estona s'anomenen serveis i els gestiona el propi \est{kernel}, també anomenat,
en aquest context, \est{systemd} \cite{Systemd}. Hi ha dos tipus de serveis
diferents, en funció dels privilegis que tenen:

\begin{itemize}
    \item Els \emph{serveis del sistema} afecten a tots els usuaris i
    s'executen sota l'usuari i context de \est{root} (excepte si es diu
    el contrari). Es pot escollir quan s'executen, ja sigui just després de
    carregar el \est{kernel} a la memòria o després que el primer usuari
    iniciï sessió. Es necessiten permisos d'administrador per fer modificacions
    en els serveis de sistema (generalment mitjançant l'ordre \ord|systemctl|).
    \item Els \emph{serveis d'usuari}, en canvi, només afecten l'usurari
    que els ha configurat. No es necessiten permisos d'administrador per
    configurar-los, i s'executen sota el mateix context, variables d'entorn i
    usuari que qui els ha configurat. Aquests serveis només es poden executar a
    partir dels darrers passos de l'arrencada del sistema, ja sigui després
    d'iniciar sessió o un cop carregat l'entorn gràfic. També utilitzen l'ordre
    \ord|systemctl|, però afegint l'opció \ord|--user|.
\end{itemize}

És important conèixer la diferència entre els dos tipus mencionats, ja que en
aquest treball es generarà un servei d'usuari i un de sistema, i cadascun té
les seves complicacions, tant en el moment d'insta\l.lació com en el moment
d'execució.

\section{Entorn gràfic a Linux}

El darrer punt a tractar en aquest capítol és la comunicació entre una
aplicació i l'entorn gràfic en un sistema basat en Linux; concretament, cal
esbrinar com aplicar canvis de rotació de la pantalla. Per sort, 
independentment de l'entorn gràfic que utilitzi un ordinador (normalment
\acro{gnome}, però també \acro{kde}), tots responen a les peticions gràfiques
sota la interfície de programació de \est{Xlib} \cite{Xlib}.

Es podria fer una bona analogia entre
els entorns gràfics i els navegadors: els navegadors, a Linux, implementen les
crides i interfície de \est{www-browser}, tot i estar implementats internament
de formes diferents. Si es vol implementar una aplicació que necessiti, per
exemple, un navegador incrustat, però qualsevol navegador serveix, es pot
indicar com a dependència \est{www-browser} en lloc de, per exemple, \est{Firefox}.

\subsection{Servidor gràfic \est{Xorg}}

\est{Xorg} és un servidor gràfic per gestionar des de configuracions de
pantalla fins a detalls de rendiment per a certes finestres. Els programes
utilitzen la llibreria \est{Xlib} per interactuar-hi.
\est{Xlib} és una llibreria molt complexa, i té interfícies per a la majoria
dels llenguatges.

Tanmateix, sovint és més senzill utilitzar una aplicació de
la línia d'ordres que simplifica la tasca del programador. Aquesta
aplicació es diu \est{xrandr} i, d'una forma molt senzilla, permet llistar
totes les pantalles connectades a l'ordinador i canviar l'orientació
d'una d'elles \cite{Xrandr}.

A la figura \ref{fig:xorg-hyerarchy} es pot contemplar la jerarquia de la qual
es parla: \est{xrandr} segueix sent un intermediari més entre l'aplicació que
es vol crear i l'objectiu final: rotar la pantalla. De nou, en treballar amb
diverses capes torna a aparèixer la possibilitat d'utilitzar un programa
diferent per a les capes superiors: per exemple, \est{xrandr} pot ser utilitzat
des de la línia d'odres, a part de des de l'aplicació que es dissenyi.

\input{misc/xorg_hyerarchy.tex}

\subsection{Execució de \est{Xrandr} en un servei de sistema}
\label{subsec:xrandr}

Els sistemes Linux estan construïts per ser tan versàtils com sigui possible. Una
de les possibilitats és que hi hagi diferents clients connectats a la vegada
a la mateixa màquina. Aquest fet no sorprèn a ningú, ja que és ben sabut que
diversos usuaris poden connectar-se remotament i simultàniament a la mateixa
màquina mitjançant \est{ssh}. Ara bé, hi ha diverses formes (com, per exemple,
l'opció \ord|-X| de \est{ssh}) que permeten diferents sessions gràfiques
simultàniament \cite{ManSSH}.

La complicació rau en el fet que \est{xrandr} utilitza les variables d'entorn per
trobar la sessió actual. Aquestes variables es defineixen a l'inici de sessió,
quan s'inicialitza \est{Xlib}. Això vol dir que, sempre que s'executi
\est{xrandr} des de la sessió (ja sigui amb un servei de sessió o a través de
la línia d'odres) no hi haurà cap problema.
Tanmateix, si es vol executar \est{xrandr} des d'un servei de sistema o des d'un
terminal remot, el programa no trobarà la sessió actual i serà impossible
resoldre la comanda \cite{ArchWiki}.

Hi ha entre dos i tres variables d'entorn importants per al correcte funcionament
de \est{xrandr} \cite{XrandrVars}:

\begin{itemize}
    \item La variable d'entorn \verb|$DISPLAY| permet identificar el grup de
    pantalles al qual s'està connectat. En general sempre serà \verb|:0| (o 
    \verb|:1| pels sistemes més recents), però si hi ha diversos usuaris
    connectats amb diferents entorns gràfics, podria ser un altre nombre.
    \item La segona variable d'entorn necessària és \verb|$XAUTHORITY|. Aquesta
    variable conté la direcció del fitxer \fitx{Xauthority}. Aquest fitxer
    conté la \est{cookie} o galeta que permet consultar i realitzar canvis en la sessió
    actual. Com és evident, aquest fitxer només pot ser consultat per l'usuari
    propietari de la sessió (i usuaris administradors).
    \item Finalment, hi ha \verb|$XDG_RUNTIME_DIR|, que pretén reemplaçar la
    variable anterior per portar la direcció del directori que conté el fitxer
    \est{Xauthority}.
\end{itemize}

Cal tenir present que un usuari pot restringir qui té accés a modificar la
seva sessió. Per defecte, es restringeix a tothom que no tingui accés al
fitxer d'autorització, però mitjançant l'ordre \ord|xhost +| es pot permetre
que tothom pugui efectuar modificacions a la sessió d'aquell usuari \cite{Xhost}.
Tanmateix, aquesta pràctica es considera poc segura, i per aquest motiu no es
tindrà en compte durant l'elaboració d'aquest treball.

%\subsection{Linux i els controladors gràfics}
%TODO Restructurar o col·locar en un altre lloc "Experiències personals"

% Qualsevol persona que hagi provat d'insta\l.lar els controladors oficials
% d'una targeta gràfica en un entorn Linux sabrà que no és pas cap tasca trivial.
% Tot i haver millorat recentment, hi segueixen havent moltes incompatibilitats
% entre diferents versions i targetes gràfiques. En el cas concret d'aquest
% projecte s'ha utilitzat un ordinador equipat amb una \acro{nvidia gtx1050},
% un model utilitzat en molts dispositius.

% Tanmateix, en el moment de provar l'ordre \ord|xrandr| es va descobrir que,
% en funció dels controladors de la targeta gràfica que hi hagi activats a
% l'ordinador i de les seves versions, l'execució de l'ordre causa un congelament
% de mig segon aproximadament de totes les pantalles del sistema. Aquest error ja
% ha estat reportat a \cite{xrandrBug}, però no s'ha trobat cap solució
% específica.

% S'ha solucionat aquest problema desinsta\l.lant els controladors gràfics de
% \acro{nvidia}. Tanmateix, això deixava inutilitzable la connexió \acro{hdmi} de
% l'ordinador. Finalment, es va optar per actualitzar la distribució d'Ubuntu
% (de 18.04 a 24.04) on aquest error ja no ha tornat a aparèixer (n'han aparegut
% d'altres, però no han afectat pel desenvolupament d'aquest projecte).

\subsection{Transició al servidor gràfic \est{Wayland}}
\label{subsec:wayland}

El servidor gràfic de l'apartat anterior, \est{Xorg}, és un projecte molt antic
i porta acumulades bastants funcionalitats i canvis que s'ha fet durant els
anys. Si bé és molt funcional i popular, es podria crear un entorn gràfic que
funcionés d'una forma més eficient amb el maquinari actual (el \est{hardware}
ha canviat molt des dels seus inicis). Aquesta és la idea que van tenir les
persones que van impulsar \est{Wayland}.

Creat l'any 2008, ha anat recuperant totes les funcionalitats de \est{Xorg}
implementades amb una arquitectura bastant diferent. Tot i seguir sent
compatible amb alguns aspectes senzills, hi ha molts programes que deixen de
funcionar amb aquest nou servidor, especialment els que comparteixen pantalla
o hi interactuen. Des d'Ubuntu 17.10 que el sistema operatiu deixa
escollir entre els dos entorns \cite{Wayland}.

Tanmateix, un canvi d'aquesta magnitud no es fa d'una versió per una altra.
\est{Wayland} encara necessita bastants millores per fer-lo completament
compatible; per això, la seva \acro{api} no és del tot definitiva. Es preveuen
encara uns quants anys fins que no s'anunciï la data en què \est{Xorg} haurà de
deixar de ser utilitzat; i un cop passada aquesta data, el més probable és que
ordres com \ord|xrandr| segueixin funcionant, de la mateixa forma que segueixen
funcionant eines com \ord|ifconfig|, obsoletes des de fa ja molts anys
\cite{Ifconfig}.

Per aquest motiu s'ha decidit realitzar el projecte utilitzant \est{Xorg}.
D'aquesta forma s'obtindrà un programari estable, si més no durant els primers
anys. Així doncs, si el projecte té previsió de continuar més enllà d'aquest
Treball de Fi de Grau, s'haurà de preveure una migració a \est{Wayland}.
