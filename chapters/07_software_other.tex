\chapter{Disseny del \est{software} a altres sistemes operatius}
\label{cap:software-other}

Tal com s'ha dit al principi d'aquest treball de final de grau, l'objectiu
del projecte és realitzar un programari que pugui funcionar amb la gran majoria
de sistemes operatius disponibles al mercat. Tanmateix, s'ha vist que les
llibreries per a modificar aspectes gràfics dels dispositius varien molt entre
cada \est{kernel}, pel que la possibilitat de realitzar un únic programa que
funcioni per a tots els sistemes operatius queda descartada.

Degut a les limitacions de temps i dedicació d'aquest treball, no es podrà
repetir totes les tasques realitzades en el capítol anterior amb la resta
de sistemes operatius. Tanmateix, es pretén aprendre el funcionament d'aquests
per a deixar un camí més senzill si mai es volgués acabar implementant un
programari per a aquests equipaments.

En aquest capítol s'explorarà la possibilitat de llegir dades d'un sensor
\acro{usb} i modificar l'orientació d'una pantalla en els dos sistemes operatius
que, juntament amb Linux, s'utilitzen en gairebé tots els ordinadors personals.
No es fixa com a objectiu crear un programa insta\l.lable per a cada un d'ells
degut a les limitacions del projecte.

\section{\est{Software} a Windows}

El sistema operatiu Windows acostuma a proposar un gran nombre de llibreries
a disposició del programador per a poder carregar-les durant l'execució del
programa i així interactuar amb el \est{kernel}. Aquests fitxers amb
extensió \fitx{.dll} (de l'anglès \est{Dynamic Linked Library}) es poden trobar
a diversos directoris del sistema i poden ser insta\l.lats posteriorment.

Un dels grans avantatges de Windows és que un programa sol distribuir-se
juntament amb les seves dependències i llibreries, eliminant problemes de
versions mínimes suportades i compatibilitat entre diferents programes. El
gran inconvenient d'aquesta funcionalitat és que els programes ocupen més espai
de disc, i sovint s'acaba tenint algunes llibreries per duplicat.

En aquest apartat es veurà els detalls a tenir presents per a portar parts
de l'aplicació que interactuen directament amb el sistema operatiu a Windows.

\subsection{Comunicació amb el dispositiu}

De la mateixa forma que a Linux hi havia diversos \est{drivers} per a poder
interactuar amb un perifèric des de diferents capes d'abstracció, Windows també
ofereix certa flexibilitat per a treballar amb sensors. Aquesta llibreria es diu
\emph{Sensor API} i està disponible des de Windows 7 \cite{SensorMsft}.
Cal mencionar que també existeix una llibreria per a interactuar amb dispositius
\acro{hid} genèrics, o també existeix el projecte \est{libusb-win32}, que
vindrien a ser l'analogia d'\ord|hidapi| i \ord|libusb| \cite{SensorHidMsft}.

El problem d'aquesta llibreria és que no està molt ben documentada i té pocs,
tutorials, pel que ha sigut molt difícil aconseguir rebre dades del dispositiu
del projecte, i no s'ha aconseguit distingir entre dos sensors, com sí que
s'ha pogut fer a Linux. Es deixa aquesta tasca com una futura ampliació del
projecte.

En comparació amb \ord|libiio| s'ha trobat aquesta llibreria bastant més
complexa, ja que al no disposar d'exemples es sospita que no s'hagi realitzat
la cerca dels sensors de la forma més senzilla possible. De la mateixa forma,
aquesta llibreria està dissenyada per a treballar amb llenguatges de més baix
nivell que Python, i la tasca de programació no ha sigut tan ràpida com a Linux.

\subsection{Comunicació amb l'entorn gràfic}

Poder canviar la rotació d'una pantalla i poder esbrinar l'orientació actual
d'aquesta no és una tasca trivial a Windows, però tampoc és complica de més.
Tot i no disposar d'una llibreria específica per a les pantalles, Windows
disposa de l'estructura de C++ \acro{devmode}, definida a \fitx{wingdi.h}.
Aquest nom ve de l'acrònim anglès de \est{Device Mode}, i serveix per a
interactuar tant amb pantalles com amb impressores \cite{WinDevMode}.

Hi ha diverses formes d'implementar un petit programa per què utilitzi el
\acro{devmode} per a actualitzar la rotació de la pantalla, però la majoria
de tutorials ho acostumen a fer en el llenguatge de \ord|C#|, com és el cas
de l'exemple trobat a \cite{WinRotateOnline}. Tots els codis utilitzen
\fitx{user32.dll} per a enviar l'estructura modificada al \est{kernel}.

Per a demostrar la viabilitat d'aquesta alternativa s'ha creat un petit
programa que inverteix l'orientació de la pantalla. Aquest codi ha funcionat
sense gaires problemes, i s'ha vist que, utilitzant la llibreria \ord|ctypes|,
es podria passar fàcilment el codi creat a Python.

\subsection{Execució en segon pla i insta\l.lació}

Finalment, un cop s'aconsegueixi que ambdues parts del programa funcionin
correctament, es voldrà distribuir l'aplicació als usuaris. Els sistemes de
Windows disposen d'un tipus de fitxer amb extensió \fitx{.msi} (de l'anglès
\est{MicroSoft Installer}) per a insta\l.lar paquets (una analogia perfecta dels
paquets de Debian).

Un fitxer \fitx{.msi} té una estructura molt complexa, pel que es recomana
utilitzar una aplicació externa que transformi un codi més llegible al fitxer
d'insta\l.lació. El programa gratuït més popular és \est{Wix}. A la seva pàgina
web hi ha tutorials molt ben detallats sobre com crear la interfície
d'insta\l.lació i indicar al sistema quins fitxers s'han de copiar i a on
\cite{Wix}.

\est{Wix} també ofereix la possibilitat d'insta\l.lar serveis de sistema o
d'usuari afegint unes poques línies al fitxer de configuració de format
\acro{xml}. A Windows és molt més senzill alternar entre un servei de sistema
o un servei d'usuari, pel que és molt probable que tots els problemes que hi ha
hagut a Linux per a que funcioni \est{xrandr} en un servei de sistema no hi
seran en l'equivalent de Windows.

Finalment, de la mateixa forma que en els sistemes basats en Linux es pot crear
un servidor \acro{apt}, a Windows hi ha el \est{Windows Package Manager}, que
permet insta\l.lar aplicacions mitjançant l'ordre \ord|winget|. Aquest gestor
és prou recent i poc conegut, pel que gairebé no s'acostuma a utilitzar. La
majoria d'usuaris de Windows estan acostumats a haver de descarregar manualment
l'insta\l.lador de la pàgina web de l'aplicació i no obren la línia de
comandes per res.

Tot i això, està bé publicar el paquet creat al \est{Windows Package Manager},
per a facilitar l'insta\l.lació si mai no es disposa d'un navegador o es vol
automatitzar el procés. A \cite{WPM} hi ha totes les instruccions per a
penjar l'aplicació a la plataforma de Microsoft, i no sembla que sigui un
procés molt llarg: penjar el fitxer \fitx{.msi}, omplir un parell de formularis
i confirmar una adreça de correu electrònic.

\section{\est{Software} a MacOS}
\subsection{Comunicació amb el dispositiu}
\subsection{Comunicació amb l'entorn gràfic}
\subsection{Execució en segon pla i insta\l.lació}


\section{Alternativa compatible amb tots els sistemes operatius}
\label{sec:winmac-conclusions}

Tal com s'ha vist en aquest capítol, portar l'aplicació a la resta de sistemes
operatius és una tasca repetitiva i tediosa. S'ha intentat desenvolupar el codi
per a que sigui el màxim compatible amb els estàndards del sistema operatiu en
qüestió, i això ha fet que cada implementació divergís l'una de l'altra. Un clar
exemple és l'ús de \ord|libiio|, que només és disponible, de moment, en sistemes
basats en Linux.

En aquest apartat es vol proposar una alternativa de disseny del programari. En
aquest cas, no es buscarà treballar amb la capa d'abstracció més alta, sinó en
la que està disponible en el màxim nombre de sistemes operatius. En el cas del
projecte, aquesta capa seria \ord|libusb|, tal i com s'ha explicat en l'apartat
\ref{subsubsec:libusb}. D'aquesta forma, al crear un programa que utilitzi
\ord|libusb| i no \ord|libiio|, s'aconsegueix que aquest pugui funcionar també
a Windows i MacOS.

Dissenyar el programari per a treballar amb \ord|libusb| requereix realitzar
les tasques que realitzaven \ord|libhid| i \ord|libiio|. Això significarà que
probablement quedi un codi resultant més llarg i complexe, però només hi haurà
un únic programa i no tres. Haver de mantenir només una peça de programari
també ajudaria a reduir les hores de dedicació al manteniment del projecte, i
tots els costos associats.

Fer la part de la rotació de la pantalla compatible amb tots els sistemes
operatius no serà una tasca igual de senzilla, ja que encara no existeix cap
llibreria o aplicació disponible per a diferents sistemes operatius. Tanmateix,
es pot crear, per exemple, un mòdul de Python amb tres implementacions
diferents: una per Windows, una per MacOS, i una per Linux. En funció del
sistema operatiu es carrega una implementació o una altra i, al compartir
totes la mateixa \acro{api}, el programa podria funcionar correctament en tots
els entorns.

Ara que el projecte ja està fet no es realitzarà aquest canvi, ja que suposaria
començar de nou una de les parts més grans del \acro{tfg}. Tanmateix, es tindrà
en compte aquestes conclusions per a futurs treballs o projectes.
